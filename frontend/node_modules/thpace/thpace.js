(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.window = global.window || {}));
}(this, (function (exports) { 'use strict';

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  /** @deprecated */
  function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
      return r;
  }

  const EPSILON = Math.pow(2, -52);
  const EDGE_STACK = new Uint32Array(512);

  class Delaunator {

      static from(points, getX = defaultGetX, getY = defaultGetY) {
          const n = points.length;
          const coords = new Float64Array(n * 2);

          for (let i = 0; i < n; i++) {
              const p = points[i];
              coords[2 * i] = getX(p);
              coords[2 * i + 1] = getY(p);
          }

          return new Delaunator(coords);
      }

      constructor(coords) {
          const n = coords.length >> 1;
          if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

          this.coords = coords;

          // arrays that will store the triangulation graph
          const maxTriangles = Math.max(2 * n - 5, 0);
          this._triangles = new Uint32Array(maxTriangles * 3);
          this._halfedges = new Int32Array(maxTriangles * 3);

          // temporary arrays for tracking the edges of the advancing convex hull
          this._hashSize = Math.ceil(Math.sqrt(n));
          this._hullPrev = new Uint32Array(n); // edge to prev edge
          this._hullNext = new Uint32Array(n); // edge to next edge
          this._hullTri = new Uint32Array(n); // edge to adjacent triangle
          this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

          // temporary arrays for sorting points
          this._ids = new Uint32Array(n);
          this._dists = new Float64Array(n);

          this.update();
      }

      update() {
          const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
          const n = coords.length >> 1;

          // populate an array of point indices; calculate input data bbox
          let minX = Infinity;
          let minY = Infinity;
          let maxX = -Infinity;
          let maxY = -Infinity;

          for (let i = 0; i < n; i++) {
              const x = coords[2 * i];
              const y = coords[2 * i + 1];
              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;
              this._ids[i] = i;
          }
          const cx = (minX + maxX) / 2;
          const cy = (minY + maxY) / 2;

          let minDist = Infinity;
          let i0, i1, i2;

          // pick a seed point close to the center
          for (let i = 0; i < n; i++) {
              const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
              if (d < minDist) {
                  i0 = i;
                  minDist = d;
              }
          }
          const i0x = coords[2 * i0];
          const i0y = coords[2 * i0 + 1];

          minDist = Infinity;

          // find the point closest to the seed
          for (let i = 0; i < n; i++) {
              if (i === i0) continue;
              const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
              if (d < minDist && d > 0) {
                  i1 = i;
                  minDist = d;
              }
          }
          let i1x = coords[2 * i1];
          let i1y = coords[2 * i1 + 1];

          let minRadius = Infinity;

          // find the third point which forms the smallest circumcircle with the first two
          for (let i = 0; i < n; i++) {
              if (i === i0 || i === i1) continue;
              const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
              if (r < minRadius) {
                  i2 = i;
                  minRadius = r;
              }
          }
          let i2x = coords[2 * i2];
          let i2y = coords[2 * i2 + 1];

          if (minRadius === Infinity) {
              // order collinear points by dx (or dy if all x are identical)
              // and return the list as a hull
              for (let i = 0; i < n; i++) {
                  this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
              }
              quicksort(this._ids, this._dists, 0, n - 1);
              const hull = new Uint32Array(n);
              let j = 0;
              for (let i = 0, d0 = -Infinity; i < n; i++) {
                  const id = this._ids[i];
                  if (this._dists[id] > d0) {
                      hull[j++] = id;
                      d0 = this._dists[id];
                  }
              }
              this.hull = hull.subarray(0, j);
              this.triangles = new Uint32Array(0);
              this.halfedges = new Uint32Array(0);
              return;
          }

          // swap the order of the seed points for counter-clockwise orientation
          if (orient(i0x, i0y, i1x, i1y, i2x, i2y)) {
              const i = i1;
              const x = i1x;
              const y = i1y;
              i1 = i2;
              i1x = i2x;
              i1y = i2y;
              i2 = i;
              i2x = x;
              i2y = y;
          }

          const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
          this._cx = center.x;
          this._cy = center.y;

          for (let i = 0; i < n; i++) {
              this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
          }

          // sort the points by distance from the seed triangle circumcenter
          quicksort(this._ids, this._dists, 0, n - 1);

          // set up the seed triangle as the starting hull
          this._hullStart = i0;
          let hullSize = 3;

          hullNext[i0] = hullPrev[i2] = i1;
          hullNext[i1] = hullPrev[i0] = i2;
          hullNext[i2] = hullPrev[i1] = i0;

          hullTri[i0] = 0;
          hullTri[i1] = 1;
          hullTri[i2] = 2;

          hullHash.fill(-1);
          hullHash[this._hashKey(i0x, i0y)] = i0;
          hullHash[this._hashKey(i1x, i1y)] = i1;
          hullHash[this._hashKey(i2x, i2y)] = i2;

          this.trianglesLen = 0;
          this._addTriangle(i0, i1, i2, -1, -1, -1);

          for (let k = 0, xp, yp; k < this._ids.length; k++) {
              const i = this._ids[k];
              const x = coords[2 * i];
              const y = coords[2 * i + 1];

              // skip near-duplicate points
              if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
              xp = x;
              yp = y;

              // skip seed triangle points
              if (i === i0 || i === i1 || i === i2) continue;

              // find a visible edge on the convex hull using edge hash
              let start = 0;
              for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                  start = hullHash[(key + j) % this._hashSize];
                  if (start !== -1 && start !== hullNext[start]) break;
              }

              start = hullPrev[start];
              let e = start, q;
              while (q = hullNext[e], !orient(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1])) {
                  e = q;
                  if (e === start) {
                      e = -1;
                      break;
                  }
              }
              if (e === -1) continue; // likely a near-duplicate point; skip it

              // add the first triangle from the point
              let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

              // recursively flip triangles from the point until they satisfy the Delaunay condition
              hullTri[i] = this._legalize(t + 2);
              hullTri[e] = t; // keep track of boundary triangles on the hull
              hullSize++;

              // walk forward through the hull, adding more triangles and flipping recursively
              let n = hullNext[e];
              while (q = hullNext[n], orient(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1])) {
                  t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                  hullTri[i] = this._legalize(t + 2);
                  hullNext[n] = n; // mark as removed
                  hullSize--;
                  n = q;
              }

              // walk backward from the other side, adding more triangles and flipping
              if (e === start) {
                  while (q = hullPrev[e], orient(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1])) {
                      t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                      this._legalize(t + 2);
                      hullTri[q] = t;
                      hullNext[e] = e; // mark as removed
                      hullSize--;
                      e = q;
                  }
              }

              // update the hull indices
              this._hullStart = hullPrev[i] = e;
              hullNext[e] = hullPrev[n] = i;
              hullNext[i] = n;

              // save the two new edges in the hash table
              hullHash[this._hashKey(x, y)] = i;
              hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
          }

          this.hull = new Uint32Array(hullSize);
          for (let i = 0, e = this._hullStart; i < hullSize; i++) {
              this.hull[i] = e;
              e = hullNext[e];
          }

          // trim typed triangle mesh arrays
          this.triangles = this._triangles.subarray(0, this.trianglesLen);
          this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
      }

      _hashKey(x, y) {
          return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
      }

      _legalize(a) {
          const {_triangles: triangles, _halfedges: halfedges, coords} = this;

          let i = 0;
          let ar = 0;

          // recursion eliminated with a fixed-size stack
          while (true) {
              const b = halfedges[a];

              /* if the pair of triangles doesn't satisfy the Delaunay condition
               * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
               * then do the same check/flip recursively for the new pair of triangles
               *
               *           pl                    pl
               *          /||\                  /  \
               *       al/ || \bl            al/    \a
               *        /  ||  \              /      \
               *       /  a||b  \    flip    /___ar___\
               *     p0\   ||   /p1   =>   p0\---bl---/p1
               *        \  ||  /              \      /
               *       ar\ || /br             b\    /br
               *          \||/                  \  /
               *           pr                    pr
               */
              const a0 = a - a % 3;
              ar = a0 + (a + 2) % 3;

              if (b === -1) { // convex hull edge
                  if (i === 0) break;
                  a = EDGE_STACK[--i];
                  continue;
              }

              const b0 = b - b % 3;
              const al = a0 + (a + 1) % 3;
              const bl = b0 + (b + 2) % 3;

              const p0 = triangles[ar];
              const pr = triangles[a];
              const pl = triangles[al];
              const p1 = triangles[bl];

              const illegal = inCircle(
                  coords[2 * p0], coords[2 * p0 + 1],
                  coords[2 * pr], coords[2 * pr + 1],
                  coords[2 * pl], coords[2 * pl + 1],
                  coords[2 * p1], coords[2 * p1 + 1]);

              if (illegal) {
                  triangles[a] = p1;
                  triangles[b] = p0;

                  const hbl = halfedges[bl];

                  // edge swapped on the other side of the hull (rare); fix the halfedge reference
                  if (hbl === -1) {
                      let e = this._hullStart;
                      do {
                          if (this._hullTri[e] === bl) {
                              this._hullTri[e] = a;
                              break;
                          }
                          e = this._hullPrev[e];
                      } while (e !== this._hullStart);
                  }
                  this._link(a, hbl);
                  this._link(b, halfedges[ar]);
                  this._link(ar, bl);

                  const br = b0 + (b + 1) % 3;

                  // don't worry about hitting the cap: it can only happen on extremely degenerate input
                  if (i < EDGE_STACK.length) {
                      EDGE_STACK[i++] = br;
                  }
              } else {
                  if (i === 0) break;
                  a = EDGE_STACK[--i];
              }
          }

          return ar;
      }

      _link(a, b) {
          this._halfedges[a] = b;
          if (b !== -1) this._halfedges[b] = a;
      }

      // add a new triangle given vertex indices and adjacent half-edge ids
      _addTriangle(i0, i1, i2, a, b, c) {
          const t = this.trianglesLen;

          this._triangles[t] = i0;
          this._triangles[t + 1] = i1;
          this._triangles[t + 2] = i2;

          this._link(t, a);
          this._link(t + 1, b);
          this._link(t + 2, c);

          this.trianglesLen += 3;

          return t;
      }
  }

  // monotonically increases with real angle, but doesn't need expensive trigonometry
  function pseudoAngle(dx, dy) {
      const p = dx / (Math.abs(dx) + Math.abs(dy));
      return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
  }

  function dist(ax, ay, bx, by) {
      const dx = ax - bx;
      const dy = ay - by;
      return dx * dx + dy * dy;
  }

  // return 2d orientation sign if we're confident in it through J. Shewchuk's error bound check
  function orientIfSure(px, py, rx, ry, qx, qy) {
      const l = (ry - py) * (qx - px);
      const r = (rx - px) * (qy - py);
      return Math.abs(l - r) >= 3.3306690738754716e-16 * Math.abs(l + r) ? l - r : 0;
  }

  // a more robust orientation test that's stable in a given triangle (to fix robustness issues)
  function orient(rx, ry, qx, qy, px, py) {
      const sign = orientIfSure(px, py, rx, ry, qx, qy) ||
      orientIfSure(rx, ry, qx, qy, px, py) ||
      orientIfSure(qx, qy, px, py, rx, ry);
      return sign < 0;
  }

  function inCircle(ax, ay, bx, by, cx, cy, px, py) {
      const dx = ax - px;
      const dy = ay - py;
      const ex = bx - px;
      const ey = by - py;
      const fx = cx - px;
      const fy = cy - py;

      const ap = dx * dx + dy * dy;
      const bp = ex * ex + ey * ey;
      const cp = fx * fx + fy * fy;

      return dx * (ey * cp - bp * fy) -
             dy * (ex * cp - bp * fx) +
             ap * (ex * fy - ey * fx) < 0;
  }

  function circumradius(ax, ay, bx, by, cx, cy) {
      const dx = bx - ax;
      const dy = by - ay;
      const ex = cx - ax;
      const ey = cy - ay;

      const bl = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const d = 0.5 / (dx * ey - dy * ex);

      const x = (ey * bl - dy * cl) * d;
      const y = (dx * cl - ex * bl) * d;

      return x * x + y * y;
  }

  function circumcenter(ax, ay, bx, by, cx, cy) {
      const dx = bx - ax;
      const dy = by - ay;
      const ex = cx - ax;
      const ey = cy - ay;

      const bl = dx * dx + dy * dy;
      const cl = ex * ex + ey * ey;
      const d = 0.5 / (dx * ey - dy * ex);

      const x = ax + (ey * bl - dy * cl) * d;
      const y = ay + (dx * cl - ex * bl) * d;

      return {x, y};
  }

  function quicksort(ids, dists, left, right) {
      if (right - left <= 20) {
          for (let i = left + 1; i <= right; i++) {
              const temp = ids[i];
              const tempDist = dists[temp];
              let j = i - 1;
              while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
              ids[j + 1] = temp;
          }
      } else {
          const median = (left + right) >> 1;
          let i = left + 1;
          let j = right;
          swap(ids, median, i);
          if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
          if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
          if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

          const temp = ids[i];
          const tempDist = dists[temp];
          while (true) {
              do i++; while (dists[ids[i]] < tempDist);
              do j--; while (dists[ids[j]] > tempDist);
              if (j < i) break;
              swap(ids, i, j);
          }
          ids[left + 1] = ids[j];
          ids[j] = temp;

          if (right - i + 1 >= j - left) {
              quicksort(ids, dists, i, right);
              quicksort(ids, dists, left, j - 1);
          } else {
              quicksort(ids, dists, left, j - 1);
              quicksort(ids, dists, i, right);
          }
      }
  }

  function swap(arr, i, j) {
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
  }

  function defaultGetX(p) {
      return p[0];
  }
  function defaultGetY(p) {
      return p[1];
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var stats_min = createCommonjsModule(function (module, exports) {
  // stats.js - http://github.com/mrdoob/stats.js
  (function(f,e){module.exports=e();})(commonjsGlobal,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a;}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();
  u(++l%c.children.length);},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var t=e(new f.Panel("MB","#f08","#201"));u(0);return {REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now();},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/
  1048576,d.jsHeapSizeLimit/1048576);}return c},update:function(){k=this.end();},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);
  b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return {dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p));}}};return f});
  });

  var colorName = {
  	"aliceblue": [240, 248, 255],
  	"antiquewhite": [250, 235, 215],
  	"aqua": [0, 255, 255],
  	"aquamarine": [127, 255, 212],
  	"azure": [240, 255, 255],
  	"beige": [245, 245, 220],
  	"bisque": [255, 228, 196],
  	"black": [0, 0, 0],
  	"blanchedalmond": [255, 235, 205],
  	"blue": [0, 0, 255],
  	"blueviolet": [138, 43, 226],
  	"brown": [165, 42, 42],
  	"burlywood": [222, 184, 135],
  	"cadetblue": [95, 158, 160],
  	"chartreuse": [127, 255, 0],
  	"chocolate": [210, 105, 30],
  	"coral": [255, 127, 80],
  	"cornflowerblue": [100, 149, 237],
  	"cornsilk": [255, 248, 220],
  	"crimson": [220, 20, 60],
  	"cyan": [0, 255, 255],
  	"darkblue": [0, 0, 139],
  	"darkcyan": [0, 139, 139],
  	"darkgoldenrod": [184, 134, 11],
  	"darkgray": [169, 169, 169],
  	"darkgreen": [0, 100, 0],
  	"darkgrey": [169, 169, 169],
  	"darkkhaki": [189, 183, 107],
  	"darkmagenta": [139, 0, 139],
  	"darkolivegreen": [85, 107, 47],
  	"darkorange": [255, 140, 0],
  	"darkorchid": [153, 50, 204],
  	"darkred": [139, 0, 0],
  	"darksalmon": [233, 150, 122],
  	"darkseagreen": [143, 188, 143],
  	"darkslateblue": [72, 61, 139],
  	"darkslategray": [47, 79, 79],
  	"darkslategrey": [47, 79, 79],
  	"darkturquoise": [0, 206, 209],
  	"darkviolet": [148, 0, 211],
  	"deeppink": [255, 20, 147],
  	"deepskyblue": [0, 191, 255],
  	"dimgray": [105, 105, 105],
  	"dimgrey": [105, 105, 105],
  	"dodgerblue": [30, 144, 255],
  	"firebrick": [178, 34, 34],
  	"floralwhite": [255, 250, 240],
  	"forestgreen": [34, 139, 34],
  	"fuchsia": [255, 0, 255],
  	"gainsboro": [220, 220, 220],
  	"ghostwhite": [248, 248, 255],
  	"gold": [255, 215, 0],
  	"goldenrod": [218, 165, 32],
  	"gray": [128, 128, 128],
  	"green": [0, 128, 0],
  	"greenyellow": [173, 255, 47],
  	"grey": [128, 128, 128],
  	"honeydew": [240, 255, 240],
  	"hotpink": [255, 105, 180],
  	"indianred": [205, 92, 92],
  	"indigo": [75, 0, 130],
  	"ivory": [255, 255, 240],
  	"khaki": [240, 230, 140],
  	"lavender": [230, 230, 250],
  	"lavenderblush": [255, 240, 245],
  	"lawngreen": [124, 252, 0],
  	"lemonchiffon": [255, 250, 205],
  	"lightblue": [173, 216, 230],
  	"lightcoral": [240, 128, 128],
  	"lightcyan": [224, 255, 255],
  	"lightgoldenrodyellow": [250, 250, 210],
  	"lightgray": [211, 211, 211],
  	"lightgreen": [144, 238, 144],
  	"lightgrey": [211, 211, 211],
  	"lightpink": [255, 182, 193],
  	"lightsalmon": [255, 160, 122],
  	"lightseagreen": [32, 178, 170],
  	"lightskyblue": [135, 206, 250],
  	"lightslategray": [119, 136, 153],
  	"lightslategrey": [119, 136, 153],
  	"lightsteelblue": [176, 196, 222],
  	"lightyellow": [255, 255, 224],
  	"lime": [0, 255, 0],
  	"limegreen": [50, 205, 50],
  	"linen": [250, 240, 230],
  	"magenta": [255, 0, 255],
  	"maroon": [128, 0, 0],
  	"mediumaquamarine": [102, 205, 170],
  	"mediumblue": [0, 0, 205],
  	"mediumorchid": [186, 85, 211],
  	"mediumpurple": [147, 112, 219],
  	"mediumseagreen": [60, 179, 113],
  	"mediumslateblue": [123, 104, 238],
  	"mediumspringgreen": [0, 250, 154],
  	"mediumturquoise": [72, 209, 204],
  	"mediumvioletred": [199, 21, 133],
  	"midnightblue": [25, 25, 112],
  	"mintcream": [245, 255, 250],
  	"mistyrose": [255, 228, 225],
  	"moccasin": [255, 228, 181],
  	"navajowhite": [255, 222, 173],
  	"navy": [0, 0, 128],
  	"oldlace": [253, 245, 230],
  	"olive": [128, 128, 0],
  	"olivedrab": [107, 142, 35],
  	"orange": [255, 165, 0],
  	"orangered": [255, 69, 0],
  	"orchid": [218, 112, 214],
  	"palegoldenrod": [238, 232, 170],
  	"palegreen": [152, 251, 152],
  	"paleturquoise": [175, 238, 238],
  	"palevioletred": [219, 112, 147],
  	"papayawhip": [255, 239, 213],
  	"peachpuff": [255, 218, 185],
  	"peru": [205, 133, 63],
  	"pink": [255, 192, 203],
  	"plum": [221, 160, 221],
  	"powderblue": [176, 224, 230],
  	"purple": [128, 0, 128],
  	"rebeccapurple": [102, 51, 153],
  	"red": [255, 0, 0],
  	"rosybrown": [188, 143, 143],
  	"royalblue": [65, 105, 225],
  	"saddlebrown": [139, 69, 19],
  	"salmon": [250, 128, 114],
  	"sandybrown": [244, 164, 96],
  	"seagreen": [46, 139, 87],
  	"seashell": [255, 245, 238],
  	"sienna": [160, 82, 45],
  	"silver": [192, 192, 192],
  	"skyblue": [135, 206, 235],
  	"slateblue": [106, 90, 205],
  	"slategray": [112, 128, 144],
  	"slategrey": [112, 128, 144],
  	"snow": [255, 250, 250],
  	"springgreen": [0, 255, 127],
  	"steelblue": [70, 130, 180],
  	"tan": [210, 180, 140],
  	"teal": [0, 128, 128],
  	"thistle": [216, 191, 216],
  	"tomato": [255, 99, 71],
  	"turquoise": [64, 224, 208],
  	"violet": [238, 130, 238],
  	"wheat": [245, 222, 179],
  	"white": [255, 255, 255],
  	"whitesmoke": [245, 245, 245],
  	"yellow": [255, 255, 0],
  	"yellowgreen": [154, 205, 50]
  };

  var toString = Object.prototype.toString;

  var isPlainObj = function (x) {
  	var prototype;
  	return toString.call(x) === '[object Object]' && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
  };

  var defined = function () {
      for (var i = 0; i < arguments.length; i++) {
          if (arguments[i] !== undefined) return arguments[i];
      }
  };

  var colorParse = parse;

  /**
   * Base hues
   * http://dev.w3.org/csswg/css-color/#typedef-named-hue
   */
  //FIXME: use external hue detector
  var baseHues = {
  	red: 0,
  	orange: 60,
  	yellow: 120,
  	green: 180,
  	blue: 240,
  	purple: 300
  };

  /**
   * Parse color from the string passed
   *
   * @return {Object} A space indicator `space`, an array `values` and `alpha`
   */
  function parse (cstr) {
  	var m, parts = [], alpha = 1, space;

  	if (typeof cstr === 'string') {
  		//keyword
  		if (colorName[cstr]) {
  			parts = colorName[cstr].slice();
  			space = 'rgb';
  		}

  		//reserved words
  		else if (cstr === 'transparent') {
  			alpha = 0;
  			space = 'rgb';
  			parts = [0,0,0];
  		}

  		//hex
  		else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
  			var base = cstr.slice(1);
  			var size = base.length;
  			var isShort = size <= 4;
  			alpha = 1;

  			if (isShort) {
  				parts = [
  					parseInt(base[0] + base[0], 16),
  					parseInt(base[1] + base[1], 16),
  					parseInt(base[2] + base[2], 16)
  				];
  				if (size === 4) {
  					alpha = parseInt(base[3] + base[3], 16) / 255;
  				}
  			}
  			else {
  				parts = [
  					parseInt(base[0] + base[1], 16),
  					parseInt(base[2] + base[3], 16),
  					parseInt(base[4] + base[5], 16)
  				];
  				if (size === 8) {
  					alpha = parseInt(base[6] + base[7], 16) / 255;
  				}
  			}

  			if (!parts[0]) parts[0] = 0;
  			if (!parts[1]) parts[1] = 0;
  			if (!parts[2]) parts[2] = 0;

  			space = 'rgb';
  		}

  		//color space
  		else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
  			var name = m[1];
  			var isRGB = name === 'rgb';
  			var base = name.replace(/a$/, '');
  			space = base;
  			var size = base === 'cmyk' ? 4 : base === 'gray' ? 1 : 3;
  			parts = m[2].trim()
  				.split(/\s*,\s*/)
  				.map(function (x, i) {
  					//<percentage>
  					if (/%$/.test(x)) {
  						//alpha
  						if (i === size)	return parseFloat(x) / 100
  						//rgb
  						if (base === 'rgb') return parseFloat(x) * 255 / 100
  						return parseFloat(x)
  					}
  					//hue
  					else if (base[i] === 'h') {
  						//<deg>
  						if (/deg$/.test(x)) {
  							return parseFloat(x)
  						}
  						//<base-hue>
  						else if (baseHues[x] !== undefined) {
  							return baseHues[x]
  						}
  					}
  					return parseFloat(x)
  				});

  			if (name === base) parts.push(1);
  			alpha = (isRGB) ? 1 : (parts[size] === undefined) ? 1 : parts[size];
  			parts = parts.slice(0, size);
  		}

  		//named channels case
  		else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
  			parts = cstr.match(/([0-9]+)/g).map(function (value) {
  				return parseFloat(value)
  			});

  			space = cstr.match(/([a-z])/ig).join('').toLowerCase();
  		}
  	}

  	//numeric case
  	else if (!isNaN(cstr)) {
  		space = 'rgb';
  		parts = [cstr >>> 16, (cstr & 0x00ff00) >>> 8, cstr & 0x0000ff];
  	}

  	//object case - detects css cases of rgb and hsl
  	else if (isPlainObj(cstr)) {
  		var r = defined(cstr.r, cstr.red, cstr.R, null);

  		if (r !== null) {
  			space = 'rgb';
  			parts = [
  				r,
  				defined(cstr.g, cstr.green, cstr.G),
  				defined(cstr.b, cstr.blue, cstr.B)
  			];
  		}
  		else {
  			space = 'hsl';
  			parts = [
  				defined(cstr.h, cstr.hue, cstr.H),
  				defined(cstr.s, cstr.saturation, cstr.S),
  				defined(cstr.l, cstr.lightness, cstr.L, cstr.b, cstr.brightness)
  			];
  		}

  		alpha = defined(cstr.a, cstr.alpha, cstr.opacity, 1);

  		if (cstr.opacity != null) alpha /= 100;
  	}

  	//array
  	else if (Array.isArray(cstr) || commonjsGlobal.ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(cstr)) {
  		parts = [cstr[0], cstr[1], cstr[2]];
  		space = 'rgb';
  		alpha = cstr.length === 4 ? cstr[3] : 1;
  	}

  	return {
  		space: space,
  		values: parts,
  		alpha: alpha
  	}
  }

  var hsl = {
  	name: 'hsl',
  	min: [0,0,0],
  	max: [360,100,100],
  	channel: ['hue', 'saturation', 'lightness'],
  	alias: ['HSL'],

  	rgb: function(hsl) {
  		var h = hsl[0] / 360,
  				s = hsl[1] / 100,
  				l = hsl[2] / 100,
  				t1, t2, t3, rgb, val;

  		if (s === 0) {
  			val = l * 255;
  			return [val, val, val];
  		}

  		if (l < 0.5) {
  			t2 = l * (1 + s);
  		}
  		else {
  			t2 = l + s - l * s;
  		}
  		t1 = 2 * l - t2;

  		rgb = [0, 0, 0];
  		for (var i = 0; i < 3; i++) {
  			t3 = h + 1 / 3 * - (i - 1);
  			if (t3 < 0) {
  				t3++;
  			}
  			else if (t3 > 1) {
  				t3--;
  			}

  			if (6 * t3 < 1) {
  				val = t1 + (t2 - t1) * 6 * t3;
  			}
  			else if (2 * t3 < 1) {
  				val = t2;
  			}
  			else if (3 * t3 < 2) {
  				val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
  			}
  			else {
  				val = t1;
  			}

  			rgb[i] = val * 255;
  		}

  		return rgb;
  	}
  };

  function lerp(v0, v1, t) {
      return v0*(1-t)+v1*t
  }
  var lerp_1 = lerp;

  var clamp_1 = clamp;

  function clamp(value, min, max) {
    return min < max
      ? (value < min ? min : value > max ? max : value)
      : (value < max ? max : value > min ? min : value)
  }

  /**
   * @module  color-interpolate
   * Pick color from palette by index
   */






  var colorInterpolate = interpolate;

  function interpolate (palette) {
  	palette = palette.map(function(c) {
  		c = colorParse(c);
  		if (c.space != 'rgb') {
  			if (c.space != 'hsl') throw 'c.space' + 'space is not supported.';
  			c.values = hsl.rgb(c.values);
  		}
  		c.values.push(c.alpha);
  		return c.values;
  	});

  	return function(t, mix) {
  		mix = mix || lerp_1;
  		t = clamp_1(t, 0, 1);

  		var idx = ( palette.length - 1 ) * t,
  			lIdx = Math.floor( idx ),
  			rIdx = Math.ceil( idx );

  		t = idx - lIdx;

  		var lColor = palette[lIdx], rColor = palette[rIdx];

  		var result = lColor.map(function(v, i) {
  			v = mix(v, rColor[i], t);
  			if (i < 3) v = Math.round(v);
  			return v;
  		});

  		if (result[3] === 1) {
  			return 'rgb('+result.slice(0,3)+')';
  		}
  		return 'rgba('+result+')';
  	};
  }

  var cssColors = {
    'aliceblue': '#f0f8ff',
    'antiquewhite': '#faebd7',
    'aqua': '#00ffff',
    'aquamarine': '#7fffd4',
    'azure': '#f0ffff',
    'beige': '#f5f5dc',
    'bisque': '#ffe4c4',
    'black': '#000000',
    'blanchedalmond': '#ffebcd',
    'blue': '#0000ff',
    'blueviolet': '#8a2be2',
    'brown': '#a52a2a',
    'burlywood': '#deb887',
    'cadetblue': '#5f9ea0',
    'chartreuse': '#7fff00',
    'chocolate': '#d2691e',
    'coral': '#ff7f50',
    'cornflowerblue': '#6495ed',
    'cornsilk': '#fff8dc',
    'crimson': '#dc143c',
    'cyan': '#00ffff',
    'darkblue': '#00008b',
    'darkcyan': '#008b8b',
    'darkgoldenrod': '#b8860b',
    'darkgray': '#a9a9a9',
    'darkgreen': '#006400',
    'darkkhaki': '#bdb76b',
    'darkmagenta': '#8b008b',
    'darkolivegreen': '#556b2f',
    'darkorange': '#ff8c00',
    'darkorchid': '#9932cc',
    'darkred': '#8b0000',
    'darksalmon': '#e9967a',
    'darkseagreen': '#8fbc8f',
    'darkslateblue': '#483d8b',
    'darkslategray': '#2f4f4f',
    'darkturquoise': '#00ced1',
    'darkviolet': '#9400d3',
    'deeppink': '#ff1493',
    'deepskyblue': '#00bfff',
    'dimgray': '#696969',
    'dodgerblue': '#1e90ff',
    'firebrick': '#b22222',
    'floralwhite': '#fffaf0',
    'forestgreen': '#228b22',
    'fuchsia': '#ff00ff',
    'gainsboro': '#dcdcdc',
    'ghostwhite': '#f8f8ff',
    'gold': '#ffd700',
    'goldenrod': '#daa520',
    'gray': '#808080',
    'green': '#008000',
    'greenyellow': '#adff2f',
    'honeydew': '#f0fff0',
    'hotpink': '#ff69b4',
    'indianred ': '#cd5c5c',
    'indigo': '#4b0082',
    'ivory': '#fffff0',
    'khaki': '#f0e68c',
    'lavender': '#e6e6fa',
    'lavenderblush': '#fff0f5',
    'lawngreen': '#7cfc00',
    'lemonchiffon': '#fffacd',
    'lightblue': '#add8e6',
    'lightcoral': '#f08080',
    'lightcyan': '#e0ffff',
    'lightgoldenrodyellow': '#fafad2',
    'lightgrey': '#d3d3d3',
    'lightgreen': '#90ee90',
    'lightpink': '#ffb6c1',
    'lightsalmon': '#ffa07a',
    'lightseagreen': '#20b2aa',
    'lightskyblue': '#87cefa',
    'lightslategray': '#778899',
    'lightsteelblue': '#b0c4de',
    'lightyellow': '#ffffe0',
    'lime': '#00ff00',
    'limegreen': '#32cd32',
    'linen': '#faf0e6',
    'magenta': '#ff00ff',
    'maroon': '#800000',
    'mediumaquamarine': '#66cdaa',
    'mediumblue': '#0000cd',
    'mediumorchid': '#ba55d3',
    'mediumpurple': '#9370d8',
    'mediumseagreen': '#3cb371',
    'mediumslateblue': '#7b68ee',
    'mediumspringgreen': '#00fa9a',
    'mediumturquoise': '#48d1cc',
    'mediumvioletred': '#c71585',
    'midnightblue': '#191970',
    'mintcream': '#f5fffa',
    'mistyrose': '#ffe4e1',
    'moccasin': '#ffe4b5',
    'navajowhite': '#ffdead',
    'navy': '#000080',
    'oldlace': '#fdf5e6',
    'olive': '#808000',
    'olivedrab': '#6b8e23',
    'orange': '#ffa500',
    'orangered': '#ff4500',
    'orchid': '#da70d6',
    'palegoldenrod': '#eee8aa',
    'palegreen': '#98fb98',
    'paleturquoise': '#afeeee',
    'palevioletred': '#d87093',
    'papayawhip': '#ffefd5',
    'peachpuff': '#ffdab9',
    'peru': '#cd853f',
    'pink': '#ffc0cb',
    'plum': '#dda0dd',
    'powderblue': '#b0e0e6',
    'purple': '#800080',
    'rebeccapurple': '#663399',
    'red': '#ff0000',
    'rosybrown': '#bc8f8f',
    'royalblue': '#4169e1',
    'saddlebrown': '#8b4513',
    'salmon': '#fa8072',
    'sandybrown': '#f4a460',
    'seagreen': '#2e8b57',
    'seashell': '#fff5ee',
    'sienna': '#a0522d',
    'silver': '#c0c0c0',
    'skyblue': '#87ceeb',
    'slateblue': '#6a5acd',
    'slategray': '#708090',
    'snow': '#fffafa',
    'springgreen': '#00ff7f',
    'steelblue': '#4682b4',
    'tan': '#d2b48c',
    'teal': '#008080',
    'thistle': '#d8bfd8',
    'tomato': '#ff6347',
    'turquoise': '#40e0d0',
    'violet': '#ee82ee',
    'wheat': '#f5deb3',
    'white': '#ffffff',
    'whitesmoke': '#f5f5f5',
    'yellow': '#ffff00',
    'yellowgreen': '#9acd32'
  };
  var rgb = /rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)/;
  var rgba = /rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}|.*)\)/;
  var hsla = /hsla\((\d{1,3}),\s*(\d{1,3})\%,\s*(\d{1,3})\%,\s*(\d{1,3}|.*)\)/;
  var hsl$1 = /hsl\((\d{1,3}),\s*(\d{1,3})\%,\s*(\d{1,3})\%\)/;
  var hex = /^#?([a-fA-F\d]{2})([a-fA-F\d]{2})([a-fA-F\d]{2})$/;
  /**
   * @param color - Color to parse
   * @example parseColor('rgba(255,15,50,.2)')
   * parseColor('rgb(50,60,20)')
   * parseColor('pink')
   * parseColor('hsla(120,100%,50%,0.3)')
   * @description Helper function that will parse colors for RGBA color space
   * @returns Array length 4 where each value corresponds to RGBA
   */

  function parseColor(color) {
    var match;

    if (color.match(rgb)) {
      match = color.match(rgb).slice(1, 4).map(function (num) {
        return parseInt(num);
      });
      return [match[0], match[1], match[2], 1];
    } else if (color.match(rgba)) {
      match = color.match(rgba).slice(1, 5).map(function (num) {
        return parseFloat(num);
      });
      return [match[0], match[1], match[2], match[3]];
    } else if (color.match(hsl$1)) {
      match = color.match(hsl$1).slice(1, 4).map(function (num) {
        return parseInt(num);
      });
      return __spreadArrays(hslToRgb(match[0], match[1], match[2]), [1]);
    } else if (color.match(hsla)) {
      match = color.match(hsla).slice(1, 5).map(function (num) {
        return parseFloat(num);
      });
      return __spreadArrays(hslToRgb(match[0], match[1], match[2]), [match[3]]);
    } else if (color.match(hex)) {
      return __spreadArrays(hexToRgb(color), [1]);
    } else if (typeof color === 'string') {
      var css = cssColors[color];

      if (css !== undefined) {
        return __spreadArrays(hexToRgb(css), [1]);
      } else {
        return [0, 0, 0, 0];
      }
    } else {
      console.warn("I have no idea what \"" + color + " is.\"");
      return [0, 0, 0, 0];
    }
  }
  /**
   * @description Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h, s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   * @param h - The hue
   * @param s - The saturation (percentage)
   * @param l - The lightness (percentage)
   * @returns The RGB representation
   */

  function hslToRgb(h, s, l) {
    s /= 100;
    l /= 100; // Achromatic

    if (s === 0) return [l, l, l];else {
      var hueToRgb = function hueToRgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      };

      h /= 360;
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      return [Math.round(hueToRgb(p, q, h + 1 / 3) * 255), Math.round(hueToRgb(p, q, h) * 255), Math.round(hueToRgb(p, q, h - 1 / 3) * 255)];
    }
  }
  /**
   * @description Converts a given hex color to RGB
   * @param color - The hex color
   * @returns The RGB representation
   */

  function hexToRgb(color) {
    var result = hex.exec(color);

    if (result) {
      return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)];
    } else {
      console.warn("Invalid hex used: " + color);
      return [0, 0, 0];
    }
  }
  /**
   * @description Convert color string of any type to RGBA string
   * @param color - Color string to parse
   * @returns RGBA string for CSS
   */

  function getRGBA(color) {
    if (!color) {
      console.warn("Incorrect color: " + color);
      return 'rgba(0,0,0,0)';
    }

    return "rgba(" + parseColor(color).join(',') + ")";
  }
  /**
   * @description
   * @param min The minimum value to return
   * @param max The maximum value to return
   * @param int Specifies whether the value returned should be an integer
   * @returns Random number between min and max
   */

  function getRandomNumber(min, max, _int) {
    if (_int === void 0) {
      _int = false;
    }

    if (_int) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    return Math.random() * (max - min) + min;
  }
  /**
   * @description This is a shallow object difference function
   * @param a The root object
   * @param b The new object
   * @returns Object containing the different entries
   */

  function objectDiff(a, b) {
    var diff = {};
    Object.entries(b).forEach(function (_a) {
      var key = _a[0],
          value = _a[1]; // @ts-ignore

      if (a[key] !== value) diff[key] = value;
    });
    return diff;
  }
  /**
   * @description A function to map a decimal to a color
   * @param x X coordinate of point
   * @param y Y coordinate of point
   * @param width Width of canvas
   * @param height Height of canvas
   * @param colors Array of colors specified by string
   * @param returnString Should the function return a string
   */

  function gradient(x, y, width, height, colors, returnString) {
    if (returnString === void 0) {
      returnString = true;
    }

    var per = 0;
    per = x / width;
    var per2 = 0;
    per2 = y / height;
    per = (per2 + per) / 2;

    if (per > 1) {
      per = 1;
    } else if (per < 0) {
      per = 0;
    }

    var color = colorInterpolate(colors)(per);
    var match;

    if (color.match(rgb)) {
      match = color.match(rgb).slice(1, 4).map(function (num) {
        return parseInt(num);
      });
      if (returnString) return "rgba(" + match[0] + ", " + match[1] + ", " + match[2] + ", 1)";
      return [match[0], match[1], match[2], 1];
    } else if (color.match(rgba)) {
      match = color.match(rgba).slice(1, 5).map(function (num) {
        return parseFloat(num);
      });
      if (returnString) return "rgba(" + match[0] + ", " + match[1] + ", " + match[2] + ", " + match[3] + ")";
      return [match[0], match[1], match[2], match[3]];
    } else {
      if (returnString) return "rgba(0,0,0,0)";
      return [0, 0, 0, 0];
    }
  }
  /**
   * @description Better rounding function that returns a number
   * @param value Value to round
   * @param decimals How many decimal places to round to
   * @returns Float rounded to the specified decimal place
   */

  function round(value, decimals) {
    return Number(Math.round(+(value + 'e' + decimals)) + 'e-' + decimals);
  }

  var ThpaceBase =
  /** @class */
  function () {
    function ThpaceBase(canvas, settings) {
      this.animating = false;
      this.resize = this.resize.bind(this);
      this.canvas = canvas;
      this.settings = settings;
      this.dim = {
        width: 0,
        height: 0
      };
      this.stats = new stats_min();
      this.timings = {
        triangles: new Timings(),
        particles: new Timings()
      };

      if (settings.color1 && settings.color2 && typeof settings.color1 === 'string' && typeof settings.color2 === 'string') {
        this.settings.colors = [getRGBA(settings.color1), getRGBA(settings.color2)];
      } else if (this.settings.colors) {
        this.settings.colors = this.settings.colors.map(function (color) {
          return getRGBA(color);
        });
      }

      if (settings.automaticResize) {
        window.addEventListener('resize', this.resize);
      }

      this.resize(null, false);
    }

    ThpaceBase.prototype.debug = function () {
      this.stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom

      document.body.appendChild(this.stats.dom);
    };

    ThpaceBase.prototype.resize = function (event, reInit) {

      if (reInit === void 0) {
        reInit = true;
      }

      var p = this.canvas.parentElement;

      if (p) {
        this.canvas.width = p.clientWidth;
        this.canvas.height = p.clientHeight;
      }

      if (this.dim.width !== this.canvas.width || this.dim.height !== this.canvas.height) {
        this.dim.width = this.canvas.width;
        this.dim.height = this.canvas.height;
        if (reInit) this.init();
      }
    };

    ThpaceBase.prototype.stop = function () {
      if (this.animating) this.animating = false;
    };

    ThpaceBase.prototype.resume = function () {
      if (!this.animating) this.animating = true;
    };

    return ThpaceBase;
  }();

  var Timings =
  /** @class */
  function () {
    function Timings() {
      this.min = Infinity;
      this.max = 0;
      this.current = 0;
      this.curTime = 0;
    }

    Timings.prototype.set = function (value) {
      if (value < this.min) this.min = value;
      if (value > this.max) this.max = value;
      this.current = value;
    };

    Timings.prototype.start = function () {
      this.curTime = performance.now();
    };

    Timings.prototype.end = function () {
      this.set(performance.now() - this.curTime);
    };

    return Timings;
  }();

  var defaultParticleSettings = {
    count: [2, 5],
    interval: [5000, 10000],
    radius: [1, 2],
    opacity: [0.1, 0.7],
    color: '#ffffff',
    variationX: [5, 15],
    variationY: [2.5, 7.5]
  };
  var defaultSettings = {
    triangleSize: 130,
    bleed: 120,
    noise: 60,
    colors: ['rgba(11,135,147,1)', 'rgba(54,0,51,1)'],
    pointVariationX: 20,
    pointVariationY: 35,
    pointAnimationSpeed: 7500,
    maxFps: 144,
    animationOffset: 250,
    image: undefined,
    imageOpacity: 0.4,
    automaticResize: true,
    particleSettings: defaultParticleSettings
  };

  /**
   * @description Use static method 'create' to create a thpace instance.
   * @example Thpace.create(canvas, settings});
   * @classdesc This is the main Thpace class. Used to create a thpace instance on a given canvas.
   */

  var Thpace =
  /** @class */
  function (_super) {
    __extends(Thpace, _super);

    function Thpace(canvas, settings) {
      var _this = _super.call(this, canvas, settings) || this;

      _this.animating = false;
      _this.points = [];
      _this.triangles = [];
      _this.particles = [];
      _this.lastDraw = 0;
      _this.ctx = canvas.getContext('2d');

      if (_this.settings.image) {
        _this.pattern = _this.ctx.createPattern(_this.settings.image, 'repeat');
      }

      _this.init();

      _this.animate();

      return _this;
    }
    /**
     * Create an instance of thpace on your page.
     * @param canvas - The canvas to turn into a thpace instance.
     * @param settings - Optional object with settings to control the thpace instance
     */


    Thpace.create = function (canvas, settings) {
      if (!canvas) {
        console.warn('Need a valid canvas element!');
        return;
      }

      if (settings) settings.particleSettings = _extends({}, defaultParticleSettings, settings.particleSettings);
      return new Thpace(canvas, _extends({}, defaultSettings, settings));
    };
    /**
     * @description Internal function that plots the points on the graph,
     * creates the triangles, and begins the animation.
     */


    Thpace.prototype.init = function () {
      this.stop();
      this.setupPoints();
      this.delaunate();
      this.particulate();
      this.resume();
    };

    Thpace.prototype.particulate = function () {
      this.particles = [];
      var count = this.settings.particleSettings.count;
      var screenSpace = this.dim.height * this.dim.width / (100 * 100);

      for (var i = 0; i < screenSpace; i++) {
        var toJ = count;
        if (Array.isArray(count)) toJ = getRandomNumber(count[0], count[1], true);

        for (var j = 0; j < toJ; j++) {
          this.particles.push(new Particle(this));
        }
      }
    };

    Thpace.prototype.setupPoints = function () {
      this.points = [];
      var triangleSize = this.settings.triangleSize;
      var bleed = this.settings.bleed;

      for (var x = -bleed; x < this.dim.width + bleed * 2; x += triangleSize) {
        for (var y = -bleed; y < this.dim.height + bleed * 2; y += triangleSize) {
          this.points.push({
            initX: x,
            initY: y,
            x: x,
            y: y,
            xNoise: getRandomNumber(-0.5, 0.5),
            yNoise: getRandomNumber(-0.5, 0.5)
          });
        }
      }
    };

    Thpace.prototype.delaunate = function () {
      // Responsible for populating 'triangles'
      var noise = this.settings.noise;
      this.triangles = [];
      var pointsWithNoise = this.points.map(function (p) {
        return [round(p.x + p.xNoise * noise, 14), round(p.y + p.yNoise * noise, 14)];
      });
      var triangles = Delaunator.from(pointsWithNoise).triangles;

      for (var i = 0; i < triangles.length; i += 3) {
        this.triangles.push(new Triangle(this, triangles.slice(i, i + 3)));
      }
    };
    /**
     * @description A function to update the Thpace settings. Will avoid re-defining the triangles if possible.
     * @param newSettings
     */


    Thpace.prototype.updateSettings = function (newSettings) {
      // Get difference between current settings and new settings
      var diff = objectDiff(this.settings, newSettings); // @ts-ignore

      if (newSettings.force) {
        diff = newSettings;
      } // Case: triangleSize - No way to avoid re-delaunating


      if (diff.triangleSize) {
        this.settings.triangleSize = diff.triangleSize;
        this.setupPoints();
        this.delaunate();
      } // Case: bleed - More points need to be generated, so re-delaunate


      if (diff.bleed) {
        this.settings.bleed = diff.bleed;
        this.setupPoints();
        this.delaunate();
      } // Case: noise - Noise generated can be stored as matrix. When noise is changed, go to all values and remap them on the new scale


      if (diff.noise) {
        var noise = diff.noise;
        this.settings.noise = noise;

        if (noise > this.settings.triangleSize) {
          this.delaunate();
        }
      } // Case: colors - Smoothly interpolate between colors. Not sure how to do this if there is a different amount of colors


      if (diff.colors) {
        if (Array.isArray(diff.colors)) {
          this.settings.colors = diff.colors.map(function (c) {
            return getRGBA(c);
          });
        }

        this.triangles.forEach(function (t) {
          t.updateColor();
        });
      } // Case: pointVariationX/Y - Seems trivial, however if we want it to be a smooth transition that's different


      if (diff.pointVariationX) this.settings.pointVariationX = diff.pointVariationX;
      if (diff.pointVariationY) this.settings.pointVariationY = diff.pointVariationY; // Case: pointAnimationSpeed - Also trivial

      if (diff.pointAnimationSpeed) this.settings.pointAnimationSpeed = diff.pointAnimationSpeed; // Case: maxFps - Yeah doesn't really matter, no case

      if (diff.maxFps) this.settings.maxFps = diff.maxFps; // Case: animationOffset - Trivial

      if (diff.animationOffset) this.settings.animationOffset = diff.animationOffset; // Case: image - Trivial, can't be smooth

      if (diff.image) {
        this.settings.image = diff.image;
        this.pattern = this.ctx.createPattern(this.settings.image, 'repeat');
      } // Case: imageOpacity - trivial


      if (diff.imageOpacity) this.settings.imageOpacity = diff.imageOpacity; // Case: automaticResize - trivial

      if (diff.automaticResize !== undefined) {
        this.settings.automaticResize = diff.automaticResize;

        if (diff.automaticResize) {
          window.addEventListener('resize', this.resize);
        } else {
          window.removeEventListener('resize', this.resize);
        }
      } // Now for the particles
      // Case: particleSettings


      if (diff.particleSettings) {
        diff = diff.particleSettings;
        this.settings.particleSettings = _extends({}, this.settings.particleSettings, diff);
        this.particles.forEach(function (p) {
          p.updateSettings(diff);
        });

        if (diff.count) {
          this.particulate();
        }
      }
    };

    Thpace.prototype.updatePoints = function () {
      var animationOffset = this.settings.animationOffset;
      var pointVariationX = this.settings.pointVariationX;
      var pointVariationY = this.settings.pointVariationY;
      var pointAnimationSpeed = this.settings.pointAnimationSpeed;
      var time = Math.PI * 2 * performance.now() / pointAnimationSpeed;
      this.points = this.points.map(function (p) {
        var per = p.initX / animationOffset;
        p.x = p.initX + Math.sin(per + time) * pointVariationX;
        p.y = p.initY + Math.cos(per + time) * pointVariationY;
        return p;
      });
    };

    Thpace.prototype.stop = function () {
      if (this.animating) this.animating = false;
    };

    Thpace.prototype.resume = function () {
      if (!this.animating) this.animating = true;
    };

    Thpace.prototype.animate = function () {
      var now = performance.now();
      requestAnimationFrame(this.animate.bind(this));
      if (!this.animating) return;
      var elapsed = now - this.lastDraw;
      var fpsInterval = 1000 / this.settings.maxFps;
      if (elapsed < fpsInterval) return;
      this.lastDraw = now - elapsed % fpsInterval;
      this.stats.begin();
      var ctx = this.ctx;
      ctx.clearRect(0, 0, this.dim.width, this.dim.height);
      this.timings.triangles.start();
      this.triangles.forEach(function (t) {
        t.draw();
      });
      this.timings.triangles.end();
      this.timings.particles.start();
      this.particles.forEach(function (p) {
        p.draw();
      });
      this.timings.particles.end();

      if (this.pattern) {
        ctx.globalAlpha = this.settings.imageOpacity;
        ctx.fillStyle = this.pattern;
        ctx.fillRect(0, 0, this.dim.width, this.dim.height);
        ctx.globalAlpha = 1;
      }

      this.updatePoints();
      this.stats.end();
    };

    return Thpace;
  }(ThpaceBase);

  var Triangle =
  /** @class */
  function () {
    function Triangle(parent, points) {
      this.color = '';
      this.parent = parent;
      this.points = points;
      this.updateColor();
    }

    Triangle.prototype.updateColor = function () {
      var noise = this.parent.settings.noise;
      var pointList = this.getPoints();
      var center = {
        x: 0,
        y: 0
      };

      for (var i = 0; i < pointList.length; i++) {
        var p = pointList[i];
        center.x += p.x + p.xNoise * noise;
        center.y += p.y + p.yNoise * noise;
      }

      center.x = center.x / 3;
      center.y = center.y / 3; //@ts-ignore

      this.color = gradient(center.x, center.y, this.parent.dim.width, this.parent.dim.height, this.parent.settings.colors);
    };

    Triangle.prototype.getPoints = function () {
      var points = [];

      for (var i = 0; i < this.points.length; i++) {
        points.push(this.parent.points[this.points[i]]);
      }

      return points;
    };

    Triangle.prototype.lines = function () {
      var ctx = this.parent.ctx;
      var noise = this.parent.settings.noise;
      var points = this.getPoints();
      ctx.fillStyle = this.color;
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      points.forEach(function (p, ind) {
        var x = p.x + p.xNoise * noise;
        var y = p.y + p.yNoise * noise;
        if (ind === 0) ctx.moveTo(x, y);else ctx.lineTo(x, y);
      });
      ctx.closePath();
    };

    Triangle.prototype.stroke = function () {
      this.lines();
      this.parent.ctx.stroke();
    };

    Triangle.prototype.fill = function () {
      this.lines();
      this.parent.ctx.fill();
    };

    Triangle.prototype.draw = function () {
      this.lines();
      this.parent.ctx.fill();
      this.parent.ctx.stroke();
    };

    return Triangle;
  }();

  var Particle =
  /** @class */
  function () {
    function Particle(parent) {
      this.opacity = 0;
      this.parent = parent;
      var dim = this.parent.dim;
      this.x = getRandomNumber(0, dim.width);
      this.y = getRandomNumber(0, dim.height);
      this.updateSettings(this.parent.settings.particleSettings);
    }

    Particle.prototype.updateSettings = function (newSettings) {
      if (newSettings.color || newSettings.opacity) {
        var color = parseColor(this.parent.settings.particleSettings.color);
        var opacity = newSettings.opacity ? this.parent.settings.particleSettings.opacity : this.opacity;
        if (Array.isArray(opacity)) opacity = getRandomNumber(opacity[0], opacity[1]);
        this.opacity = opacity;
        this.color = "rgba(" + color[0] + ", " + color[1] + ", " + color[2] + ", " + opacity + ")";
      }

      if (newSettings.radius) {
        var radius = newSettings.radius;
        this.radius = radius;
        if (Array.isArray(radius)) this.radius = getRandomNumber(radius[0], radius[1]);
      }

      if (newSettings.interval) {
        var interval = newSettings.interval;
        this.interval = interval;
        if (Array.isArray(interval)) this.interval = getRandomNumber(interval[0], interval[1]);
      }

      if (newSettings.variationX) {
        var variationX = newSettings.variationX;
        this.variationX = variationX;
        if (Array.isArray(variationX)) this.variationX = getRandomNumber(variationX[0], variationX[1]);
      }

      if (newSettings.variationY) {
        var variationY = newSettings.variationY;
        this.variationY = variationY;
        if (Array.isArray(variationY)) this.variationY = getRandomNumber(variationY[0], variationY[1]);
      }
    };

    Particle.prototype.shape = function () {
      var ctx = this.parent.ctx;
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.strokeStyle = this.color;
      var x = this.x + Math.sin(Math.PI * 2 * performance.now() / this.interval) * this.variationX;
      var y = this.y + Math.cos(Math.PI * 2 * performance.now() / this.interval) * this.variationY;
      ctx.arc(x, y, this.radius, 0, Math.PI * 2);
    };

    Particle.prototype.stroke = function () {
      this.shape();
      this.parent.ctx.stroke();
    };

    Particle.prototype.fill = function () {
      this.shape();
      this.parent.ctx.fill();
    };

    Particle.prototype.draw = function () {
      this.shape();
      this.parent.ctx.fill();
    };

    return Particle;
  }();

  var triangleShader = "#shader vertex\n#define PI 3.1415926538\n\nattribute vec2 aVertexPosition;\nattribute vec2 aNoise;\nattribute vec4 aColor;\n\nuniform vec2 uResolution;\nuniform float uAnimationOffset;\nuniform float uTime;\nuniform float uNoise;\nuniform float uPointVariationX;\nuniform float uPointVariationY;\nuniform float uPointAnimationSpeed;\n\nvarying vec4 vColor;\n\nvoid main(){\n\tfloat per = aVertexPosition[0] / uAnimationOffset;\n\n\tvec2 noise = aNoise * uNoise;\n\n\tfloat time = PI * 2.0 * uTime / uPointAnimationSpeed;\n\t\n\tfloat x = aVertexPosition[0] + sin(per + time) * uPointVariationX;\n\tfloat y = aVertexPosition[1] + cos(per + time) * uPointVariationY;\n\n\tvec2 translate = vec2(x,y);\n\n\ttranslate = translate + noise;\n\ttranslate = translate / uResolution;\n\ttranslate = translate * 2.0;\n\ttranslate = translate - 1.0;\n\n\tvColor = aColor;\n\n\tgl_Position = vec4(translate * vec2(1, -1), 0, 1);\n}\n\n#shader fragment\nprecision mediump float;\n\nvarying vec4 vColor;\n\nvoid main(){\n\tgl_FragColor = vColor;\n}";

  var particleShader = "#shader vertex\n#define PI 3.1415926538\n\nattribute vec2 aPoint;\nattribute float aInterval;\nattribute float aRadius;\nattribute float aVariationX;\nattribute float aVariationY;\nattribute float aOpacity;\n\nuniform float uTime;\nuniform vec2 uResolution;\n\nvarying float vOpacity;\n\nvoid main() {\n\n\tvec2 pos = aPoint;\n\n\tpos.x += sin(PI * 2.0 * uTime / aInterval) * aVariationX;\n\tpos.y += cos(PI * 2.0 * uTime / aInterval) * aVariationY;\n\n\tpos = pos / uResolution;\n\tpos = pos * 2.0;\n\tpos = pos - 1.0;\n\n\tgl_Position = vec4(pos * vec2(1, -1), 0, 1);\n\n\tgl_PointSize = aRadius * 3.0;\n\n\tvOpacity = aOpacity;\n}\n\n#shader fragment\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\nprecision mediump float;\n\nuniform vec3 uColor;\n\nvarying float vOpacity;\n\nvoid main() {\n\tfloat r = 0.0, delta = 0.0, alpha = 1.0;\n\tvec2 cxy = 2.0 * gl_PointCoord - 1.0;\n\tr = dot(cxy, cxy);\n\t#ifdef GL_OES_standard_derivatives\n\t\tdelta = fwidth(r);\n\t\talpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\n\t#endif\n\n\tvec4 color = vec4(uColor, vOpacity);\n\n\tgl_FragColor = color * alpha;\n}";

  function drawTriangles(gl, program, bindBuffers, verticeCount) {
    bindBuffers();
    gl.useProgram(program); // our shader needs the current time value for some calculations

    var uTime = gl.getUniformLocation(program, 'uTime');
    gl.uniform1f(uTime, performance.now());
    var uResolution = gl.getUniformLocation(program, 'uResolution');
    gl.uniform2f(uResolution, gl.canvas.width, gl.canvas.height);
    gl.drawArrays(gl.TRIANGLES, 0, verticeCount / 2);
  }
  function drawParticles(gl, program, bindBuffers, particleCount) {
    bindBuffers();
    gl.useProgram(program); // our shader needs the current time value for some calculations

    var uTime = gl.getUniformLocation(program, 'uTime');
    gl.uniform1f(uTime, performance.now());
    var uResolution = gl.getUniformLocation(program, 'uResolution');
    gl.uniform2f(uResolution, gl.canvas.width, gl.canvas.height);
    gl.drawArrays(gl.POINTS, 0, particleCount);
  }
  function initShaderProgram(gl, vsSource, fsSource) {
    var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
    var shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
      gl.deleteProgram(shaderProgram);
      throw new Error(gl.getProgramInfoLog(shaderProgram));
    }

    return shaderProgram;
  }
  function loadShader(gl, type, source) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      var err = gl.getShaderInfoLog(shader);
      gl.deleteShader(shader);
      throw new Error(err);
    }

    return shader;
  }
  function parseShader(shader) {
    var lines = shader.split('\n');
    var source = [[], []];
    var type = null;
    lines.forEach(function (l) {
      if (l.includes('#shader')) {
        if (l.includes('vertex')) type = 0;
        if (l.includes('fragment')) type = 1;
        return;
      }

      if (type !== null) {
        source[type].push(l);
      }
    }); //@ts-ignore

    return source.map(function (el) {
      return el.join('\n');
    });
  }

  var ThpaceGL =
  /** @class */
  function (_super) {
    __extends(ThpaceGL, _super);

    function ThpaceGL(canvas, settings) {
      var _a;

      var _this = _super.call(this, canvas, settings) || this;

      _this.verticeCount = 0;
      _this.particleCount = 0; // Get the webgl context for the canvas

      _this.gl = canvas.getContext('webgl', {
        alpha: false
      });
      var gl = _this.gl;
      gl.getExtension('GL_OES_standard_derivatives');
      gl.getExtension('OES_standard_derivatives');
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.BLEND); // Parse and compile our triangle shader code

      var _b = parseShader(triangleShader),
          vsSource = _b[0],
          fsSource = _b[1];

      _this.triangleShaderProgram = initShaderProgram(_this.gl, vsSource, fsSource); // Now the particle shader

      _a = parseShader(particleShader), vsSource = _a[0], fsSource = _a[1];
      _this.particleShaderProgram = initShaderProgram(_this.gl, vsSource, fsSource);
      _this.triangleVerticeData = {
        colors: [],
        noisedPoints: [],
        indices: new Uint32Array(),
        vertices: [],
        noise: []
      };
      _this.particlePointData = {
        points: [],
        interval: [],
        radius: [],
        opacity: [],
        variationX: [],
        variationY: []
      };
      _this.lastDraw = 0;

      _this.init();

      _this.animate();

      return _this;
    }
    /**
     * @description Check if the browser has support for webgl
     * @returns boolean
     */


    ThpaceGL.webglSupport = function () {
      try {
        var testCanvas = document.createElement('canvas');
        return !!window.WebGLRenderingContext && testCanvas.getContext('webgl');
      } catch (e) {
        return false;
      }
    };
    /**
     * @description Create an instance of thpace on your page.
     * @param canvas - The canvas to turn into a thpace instance.
     * @param settings - Optional object with settings to control the thpace instance
     */


    ThpaceGL.create = function (canvas, settings) {
      if (!canvas) {
        console.warn('Need a valid canvas element!');
        return;
      }

      if (!this.webglSupport()) {
        console.warn('Your browser does not support webgl :(');
        return;
      }

      if (settings) settings.particleSettings = _extends({}, defaultParticleSettings, settings.particleSettings);
      return new ThpaceGL(canvas, _extends({}, defaultSettings, settings));
    };

    ThpaceGL.prototype.generateVertices = function () {
      var noiseSetting = this.settings.noise;
      var points = [];
      var noiseValues = [];
      var vertices = [];
      var noise = [];
      var triangleSize = this.settings.triangleSize;
      var bleed = this.settings.bleed;

      for (var x = -bleed; x < this.dim.width + bleed * 2; x += triangleSize) {
        for (var y = -bleed; y < this.dim.height + bleed * 2; y += triangleSize) {
          points.push(x);
          points.push(y);
          noiseValues.push(getRandomNumber(-0.5, 0.5));
          noiseValues.push(getRandomNumber(-0.5, 0.5));
        }
      }

      var noisedPoints = [];

      for (var i = 0; i < points.length; i += 2) {
        noisedPoints.push([points[i] + noiseValues[i] * noiseSetting, points[i + 1] + noiseValues[i + 1] * noiseSetting]);
      }

      this.triangleVerticeData.noisedPoints = noisedPoints;
      var indices = Delaunator.from(noisedPoints).triangles;
      this.triangleVerticeData.indices = indices;
      this.calculateColors();

      for (var i = 0; i < indices.length; i++) {
        var xInd = indices[i] * 2;
        var yInd = xInd + 1;
        vertices.push(points[xInd]);
        vertices.push(points[yInd]);
        noise.push(noiseValues[xInd]);
        noise.push(noiseValues[yInd]);
      }

      this.triangleVerticeData.vertices = vertices;
      this.triangleVerticeData.noise = noise;
      this.verticeCount = vertices.length;
    };

    ThpaceGL.prototype.particulate = function () {
      var _a;

      var dim = this.dim;
      var settings = this.settings.particleSettings;
      var newData = {
        points: [],
        interval: [],
        radius: [],
        variationX: [],
        variationY: [],
        opacity: []
      };
      var count = this.settings.particleSettings.count;
      var screenSpace = this.dim.height * this.dim.width / (100 * 100);

      for (var i = 0; i < screenSpace; i++) {
        var toJ = count;
        if (Array.isArray(count)) toJ = getRandomNumber(count[0], count[1], true);

        for (var j = 0; j < toJ; j++) {
          newData.points.push(getRandomNumber(0, dim.width), getRandomNumber(0, dim.height));
          var interval = settings.interval;
          if (Array.isArray(interval)) interval = getRandomNumber(interval[0], interval[1]);
          newData.interval.push(interval);
          var radius = settings.radius;
          if (Array.isArray(radius)) radius = getRandomNumber(radius[0], radius[1]);
          newData.radius.push(radius);
          var variationX = settings.variationX;
          if (Array.isArray(variationX)) variationX = getRandomNumber(variationX[0], variationX[1]);
          newData.variationX.push(variationX);
          var variationY = settings.variationY;
          if (Array.isArray(variationY)) variationY = getRandomNumber(variationY[0], variationY[1]);
          newData.variationY.push(variationY);
          var opacity = settings.opacity;
          if (Array.isArray(opacity)) opacity = getRandomNumber(opacity[0], opacity[1]);
          newData.opacity.push(opacity);
        }
      } // particle color:


      var uColor = this.gl.getUniformLocation(this.particleShaderProgram, 'uColor');
      var c = parseColor((_a = this.settings.particleSettings) === null || _a === void 0 ? void 0 : _a.color).map(function (v, ind) {
        if ((ind + 1) % 4 !== 0) return v / 255;
        return v;
      });
      this.gl.uniform3f(uColor, c[0], c[1], c[2]);
      this.particlePointData = newData;
      this.particleCount = newData.points.length / 2;
    };

    ThpaceGL.prototype.calculateColors = function () {
      var _a = this.triangleVerticeData,
          indices = _a.indices,
          noisedPoints = _a.noisedPoints;
      var colors = [];

      for (var i = 0; i < indices.length; i += 3) {
        var p1 = noisedPoints[indices[i]];
        var p2 = noisedPoints[indices[i + 1]];
        var p3 = noisedPoints[indices[i + 2]];
        var center = {
          x: (p1[0] + p2[0] + p3[0]) / 3,
          y: (p1[1] + p2[1] + p3[1]) / 3
        };
        var color = gradient(center.x, center.y, this.dim.width, this.dim.height, this.settings.colors, false).map(function (v, ind) {
          if ((ind + 1) % 4 !== 0) return v / 255;
          return v;
        });

        for (var j = 0; j < 3; j++) {
          color.forEach(function (c) {
            colors.push(c);
          });
        }
      }

      this.triangleVerticeData.colors = colors;
    };

    ThpaceGL.prototype.setBuffer = function (program, attribName, data, size) {
      var gl = this.gl;
      var attrib = gl.getAttribLocation(program, attribName);

      if (attrib < 0) {
        console.log("Unable to find: " + attribName);
      }

      var buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      var noise = new Float32Array(data);
      gl.bufferData(gl.ARRAY_BUFFER, noise, gl.STATIC_DRAW);
      gl.vertexAttribPointer(attrib, size, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(attrib);
    };

    ThpaceGL.prototype.init = function () {
      this.stop();
      var gl = this.gl;
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // We need to create and set some buffers and variables for the gpu to read from:
      // start with triangles

      gl.useProgram(this.triangleShaderProgram); // vertex buffer / color buffer / noiseBuffer

      this.generateVertices(); // pointVariationX/Y uniform

      var uPointVariationX = gl.getUniformLocation(this.triangleShaderProgram, 'uPointVariationX');
      gl.uniform1f(uPointVariationX, this.settings.pointVariationX);
      var uPointVariationY = gl.getUniformLocation(this.triangleShaderProgram, 'uPointVariationY');
      gl.uniform1f(uPointVariationY, this.settings.pointVariationY); // pointAnimationSpeed uniform

      var uPointAnimationSpeed = gl.getUniformLocation(this.triangleShaderProgram, 'uPointAnimationSpeed');
      gl.uniform1f(uPointAnimationSpeed, this.settings.pointAnimationSpeed); // noise uniform

      var uNoise = gl.getUniformLocation(this.triangleShaderProgram, 'uNoise');
      gl.uniform1f(uNoise, this.settings.noise); // animation offset

      var uAnimationOffset = gl.getUniformLocation(this.triangleShaderProgram, 'uAnimationOffset');
      gl.uniform1f(uAnimationOffset, this.settings.animationOffset); // Now the particles:

      gl.useProgram(this.particleShaderProgram); // generate the particles

      this.particulate();
      this.resume();
    };

    ThpaceGL.prototype.bindTriangleBuffers = function () {
      this.setBuffer(this.triangleShaderProgram, 'aColor', this.triangleVerticeData.colors, 4);
      this.setBuffer(this.triangleShaderProgram, 'aVertexPosition', this.triangleVerticeData.vertices, 2);
      this.setBuffer(this.triangleShaderProgram, 'aNoise', this.triangleVerticeData.noise, 2);
    };

    ThpaceGL.prototype.bindParticleBuffers = function () {
      this.setBuffer(this.particleShaderProgram, 'aPoint', this.particlePointData.points, 2);
      this.setBuffer(this.particleShaderProgram, 'aInterval', this.particlePointData.interval, 1);
      this.setBuffer(this.particleShaderProgram, 'aRadius', this.particlePointData.radius, 1);
      this.setBuffer(this.particleShaderProgram, 'aVariationX', this.particlePointData.variationX, 1);
      this.setBuffer(this.particleShaderProgram, 'aVariationY', this.particlePointData.variationY, 1);
      this.setBuffer(this.particleShaderProgram, 'aOpacity', this.particlePointData.opacity, 1);
    };

    ThpaceGL.prototype.animate = function () {
      var gl = this.gl;
      var now = performance.now();
      requestAnimationFrame(this.animate.bind(this));
      if (!this.animating) return;
      var elapsed = now - this.lastDraw;
      var fpsInterval = 1000 / this.settings.maxFps;
      if (elapsed < fpsInterval) return;
      this.lastDraw = now - elapsed % fpsInterval;
      this.stats.begin();
      drawTriangles(this.gl, this.triangleShaderProgram, this.bindTriangleBuffers.bind(this), this.verticeCount);
      drawParticles(this.gl, this.particleShaderProgram, this.bindParticleBuffers.bind(this), this.particleCount);
      this.stats.end();
    };
    /**
     * @description A function to update the Thpace settings. Will avoid re-defining the triangles if possible.
     * @param newSettings
     */


    ThpaceGL.prototype.updateSettings = function (newSettings) {
      var _a;

      var gl = this.gl; // Get difference between current settings and new settings

      var diff = objectDiff(this.settings, newSettings); // @ts-ignore

      if (newSettings.force) {
        diff = newSettings;
      } // Case: triangleSize - No way to avoid re-delaunating


      if (diff.triangleSize) {
        this.settings.triangleSize = diff.triangleSize;
        this.generateVertices();
      } // Case: bleed - More points need to be generated, so re-delaunate


      if (diff.bleed) {
        this.settings.bleed = diff.bleed;
        this.generateVertices();
      } // Case: noise - Noise generated can be stored as matrix. When noise is changed, go to all values and remap them on the new scale


      if (diff.noise) {
        var noise = diff.noise;
        this.settings.noise = noise;
        gl.useProgram(this.triangleShaderProgram);
        var uNoise = gl.getUniformLocation(this.triangleShaderProgram, 'uNoise');
        gl.uniform1f(uNoise, this.settings.noise);

        if (noise > this.settings.triangleSize) {
          this.generateVertices();
        }
      } // Case: colors - Smoothly interpolate between colors. Not sure how to do this if there is a different amount of colors


      if (diff.colors) {
        if (Array.isArray(diff.colors)) {
          this.settings.colors = diff.colors.map(function (c) {
            return getRGBA(c);
          });
        }

        this.calculateColors();
        this.setBuffer(this.triangleShaderProgram, 'aColor', this.triangleVerticeData.colors, 4);
      } // Case: pointVariationX/Y - Seems trivial, however if we want it to be a smooth transition that's different


      if (diff.pointVariationX) {
        this.settings.pointVariationX = diff.pointVariationX;
        gl.useProgram(this.triangleShaderProgram);
        var uPointVariationX = gl.getUniformLocation(this.triangleShaderProgram, 'uPointVariationX');
        gl.uniform1f(uPointVariationX, this.settings.pointVariationX);
      }

      if (diff.pointVariationY) {
        this.settings.pointVariationY = diff.pointVariationY;
        gl.useProgram(this.triangleShaderProgram);
        var uPointVariationY = gl.getUniformLocation(this.triangleShaderProgram, 'uPointVariationY');
        gl.uniform1f(uPointVariationY, this.settings.pointVariationY);
      } // Case: pointAnimationSpeed - Also trivial


      if (diff.pointAnimationSpeed) {
        this.settings.pointAnimationSpeed = diff.pointAnimationSpeed;
        gl.useProgram(this.triangleShaderProgram);
        var uPointAnimationSpeed = gl.getUniformLocation(this.triangleShaderProgram, 'uPointAnimationSpeed');
        gl.uniform1f(uPointAnimationSpeed, this.settings.pointAnimationSpeed);
      } // Case: maxFps - Yeah doesn't really matter, no case


      if (diff.maxFps) this.settings.maxFps = diff.maxFps; // Case: animationOffset - Trivial

      if (diff.animationOffset) {
        this.settings.animationOffset = diff.animationOffset;
        gl.useProgram(this.triangleShaderProgram);
        var uAnimationOffset = gl.getUniformLocation(this.triangleShaderProgram, 'uAnimationOffset');
        gl.uniform1f(uAnimationOffset, this.settings.animationOffset);
      } // Case: image - Trivial, can't be smooth


      if (diff.image) {
        this.settings.image = diff.image;
      } // Case: imageOpacity - trivial


      if (diff.imageOpacity) {
        this.settings.imageOpacity = diff.imageOpacity;
      } // Case: automaticResize - trivial


      if (diff.automaticResize !== undefined) {
        this.settings.automaticResize = diff.automaticResize;

        if (diff.automaticResize) {
          window.addEventListener('resize', this.resize);
        } else {
          window.removeEventListener('resize', this.resize);
        }
      } // Now for the particles
      // Case: particleSettings


      if (diff.particleSettings) {
        diff = diff.particleSettings;
        this.settings.particleSettings = _extends({}, this.settings.particleSettings, diff);

        if (diff.color) {
          var uColor = gl.getUniformLocation(this.particleShaderProgram, 'uColor');
          var c = parseColor((_a = this.settings.particleSettings) === null || _a === void 0 ? void 0 : _a.color).map(function (v, ind) {
            if ((ind + 1) % 4 !== 0) return v / 255;
            return v;
          });
          gl.uniform3f(uColor, c[0], c[1], c[2]);
          return;
        }

        this.particulate();
      }
    };

    return ThpaceGL;
  }(ThpaceBase);

  exports.Thpace = Thpace;
  exports.ThpaceGL = ThpaceGL;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
